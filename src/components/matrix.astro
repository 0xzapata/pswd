<div class="matrix">
  <canvas id="canvas"></canvas>
  <canvas id="canvas2"></canvas>
  <div class="overlay"></div>
</div>

<script is:inline>
  var canvas = document.getElementById('canvas'),
    ctx = canvas.getContext('2d'),
    canvas2 = document.getElementById('canvas2'),
    ctx2 = canvas2.getContext('2d'),
    charArr = [
      'a',
      'b',
      'c',
      'd',
      'e',
      'f',
      'g',
      'h',
      'i',
      'j',
      'k',
      'l',
      'm',
      'n',
      'o',
      'p',
      'q',
      'r',
      's',
      't',
      'u',
      'v',
      'w',
      'x',
      'y',
      'z',
    ],
    fallingCharArr = [],
    fontSize = 10,
    cw = window.innerWidth,
    ch = window.innerHeight,
    maxColums = Math.floor(cw / fontSize);

  // Set initial canvas sizes
  canvas.width = canvas2.width = cw;
  canvas.height = canvas2.height = ch;

  // Function to recalculate canvas size on window resize
  function resizeCanvas() {
    cw = window.innerWidth;
    ch = window.innerHeight;
    maxColums = Math.floor(cw / fontSize);

    // Adjust the canvas size
    canvas.width = canvas2.width = cw;
    canvas.height = canvas2.height = ch;

    // Reinitialize falling characters
    fallingCharArr = [];
    for (var i = 0; i < maxColums; i++) {
      fallingCharArr.push(new Point(i * fontSize, randomFloat(-500, 0)));
    }
  }

  // Helper functions
  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min) + min);
  }

  function randomFloat(min, max) {
    return Math.random() * (max - min) + min;
  }

  function Point(x, y) {
    this.x = x;
    this.y = y;
  }

  // Method to draw a character
  Point.prototype.draw = function (ctx) {
    this.value = charArr[randomInt(0, charArr.length - 1)].toUpperCase();
    this.speed = randomFloat(1, 5);

    ctx2.fillStyle = 'rgba(255,255,255,0.8)';
    ctx2.font = fontSize + 'px san-serif';
    ctx2.fillText(this.value, this.x, this.y);

    ctx.fillStyle = '#0F0';
    ctx.font = fontSize + 'px san-serif';
    ctx.fillText(this.value, this.x, this.y);

    this.y += this.speed;
    if (this.y > ch) {
      this.y = randomFloat(-100, 0);
      this.speed = randomFloat(2, 5);
    }
  };

  // Create falling characters
  for (var i = 0; i < maxColums; i++) {
    fallingCharArr.push(new Point(i * fontSize, randomFloat(-500, 0)));
  }

  // Animation update function
  function update() {
    ctx.fillStyle = 'rgba(9,9,11,0.05)';
    ctx.fillRect(0, 0, cw, ch);

    ctx2.clearRect(0, 0, cw, ch);

    var i = fallingCharArr.length;
    while (i--) {
      fallingCharArr[i].draw(ctx);
    }

    requestAnimationFrame(update);
  }

  // Event listener for window resize
  window.addEventListener('resize', resizeCanvas);

  // Start the animation
  update();
</script>

<style>
  canvas {
    position: absolute;
    top: 0;
    left: 0;
    display: block;
  }

  canvas#canvas2 {
    background-color: var(--color-neutral-50);
  }

  .matrix {
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  .overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(rgb(9 9 11 / 60%), var(--color-neutral-50));
    backdrop-filter: grayscale(100%);
  }
</style>
